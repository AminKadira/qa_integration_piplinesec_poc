// vars/createSecurityAuditLog.groovy
def call() {
    script {
        echo "Creating security audit log"
        
        def auditData = [
            metadata: [
                timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'"),
                pipeline: env.JOB_NAME,
                buildNumber: env.BUILD_NUMBER,
                buildHash: env.BUILD_HASH,
                environment: env.ENVIRONMENT ?: 'dev',
                executor: env.EXECUTOR_NUMBER,
                nodeLabels: env.NODE_LABELS?.split(' ') ?: []
            ],
            security: [
                enhancedSecurity: env.ENHANCED_SECURITY == 'true',
                protectedBranch: env.ENHANCED_SECURITY == 'true',
                repositoryValidation: true,
                artifactsSigned: fileExists('signatures.manifest.asc'),
                sastAnalysis: env.SONAR_ANALYSIS_COMPLETED == 'true',
                dependencyCheck: env.OWASP_SCAN_COMPLETED == 'true'
            ],
            repositories: [
                application: [
                    commit: env.REPO_COMMIT_HASH,
                    branch: env.REPO_BRANCH,
                    url: readJSON(file: 'config/pipeline.json').repositories.application.url
                ]
            ],
            compliance: [
                owaspCompliant: env.OWASP_SCAN_PASSED == 'true',
                qualityGate: env.SONAR_QUALITY_GATE_STATUS,
                vulnerabilitiesFound: env.SECURITY_VULNERABILITIES?.toInteger() ?: 0,
                securityThreshold: readJSON(file: 'config/security.json').owasp.dependencyCheck.failOnCVSS
            ]
        ]
        
        // Enrichissement données environnement
        if (env.SONAR_ANALYSIS_URL) {
            auditData.reports.sonarQube = env.SONAR_ANALYSIS_URL
        }
        
        if (env.DEPENDENCY_CHECK_REPORT) {
            auditData.reports.owaspDependencyCheck = env.DEPENDENCY_CHECK_REPORT
        }
        
        // Génération audit JSON
        writeJSON file: 'security-audit.json', json: auditData, pretty: 4
        
        // Génération audit lisible
        sh """
            cat > security-audit.md << 'EOF'
# Security Audit Report

**Pipeline:** ${env.JOB_NAME} #${env.BUILD_NUMBER}  
**Timestamp:** ${auditData.metadata.timestamp}  
**Environment:** ${auditData.metadata.environment}  
**Build Hash:** ${env.BUILD_HASH ?: 'unknown'}

## Security Status
- **Enhanced Security:** ${auditData.security.enhancedSecurity ? 'Active' : 'Standard'}
- **Artifacts Signed:** ${auditData.security.artifactsSigned ? 'Yes' : 'No'}
- **SAST Analysis:** ${auditData.security.sastAnalysis ? 'Completed' : 'Skipped'}
- **Dependency Check:** ${auditData.security.dependencyCheck ? 'Passed' : 'Failed'}

## Compliance
- **OWASP Compliant:** ${auditData.compliance.owaspCompliant ? 'Yes' : 'No'}
- **Quality Gate:** ${env.SONAR_QUALITY_GATE_STATUS ?: 'Not Available'}
- **Security Threshold:** CVSS ≥ ${auditData.compliance.securityThreshold}
- **Vulnerabilities Found:** ${auditData.compliance.vulnerabilitiesFound}

## Repository Information
- **Commit:** ${auditData.repositories.application.commit ?: 'unknown'}
- **Branch:** ${auditData.repositories.application.branch ?: 'unknown'}

---
*Generated by DevSecOps Pipeline - ${auditData.metadata.timestamp}*
EOF
        """
        
        // Archive audit logs
        archiveArtifacts artifacts: 'security-audit.json,security-audit.md', fingerprint: true
        
        // Publication HTML rapport
        publishHTML([
            allowMissing: false,
            alwaysLinkToLastBuild: true,
            keepAll: true,
            reportDir: '.',
            reportFiles: 'security-audit.md',
            reportName: 'Security Audit Report'
        ])
        
        echo "Security audit log created successfully"
    }
}