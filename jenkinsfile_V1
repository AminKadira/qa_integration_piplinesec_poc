pipeline {
    agent any
    
    environment {
        // Secrets via Jenkins Credentials
        SONAR_TOKEN = credentials('sonarqube-token')
        REGISTRY_CREDS = credentials('container-registry')
        
        // Security scanning tools
        DEPENDENCY_CHECK_DATA = '/opt/dependency-check/data'
        SECURITY_SCAN_THRESHOLD = 'MEDIUM'
        
        // Build security
        BUILD_TIMESTAMP = new Date().format('yyyy-MM-dd HH:mm:ss')
        BUILD_HASH = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
    }
    
    stages {
        stage('Security Initialization') {
            steps {
                echo "======================================================"
                echo "OWASP Security Pipeline - SPF Invoice Service"
                echo "Build Hash: ${BUILD_HASH}"
                echo "======================================================"
                
                // Workspace isolation et nettoyage sécurisé
                deleteDir()
                
                script {
                    // Validation environnement sécurisé
                    if (!env.SONAR_TOKEN) {
                        error("SECURITY: SonarQube token not configured")
                    }
                }
            }
        }
        
        stage('Secure Checkout') {
            parallel {
                stage('Application Repository') {
                    steps {
                        dir('app') {
                            // Checkout avec validation signature
                            git branch: 'main',
                                url: 'http://localhost:3000/admin/spf.invoice.service',
                                credentialsId: 'git-credentials'
                            
                            // Validation intégrité
                            sh '''
                                echo "SECURITY: Validating repository integrity..."
                                git fsck --full --strict
                                echo "SUCCESS: Repository integrity verified"
                            '''
                        }
                    }
                }
                
                stage('Test Repository') {
                    steps {
                        dir('tests') {
                            git branch: 'main',
                                url: 'http://localhost:3000/admin/spf-invoice-tests',
                                credentialsId: 'git-credentials'
                            
                            sh 'git fsck --full --strict'
                        }
                    }
                }
            }
        }
        
        stage('Dependency Security Scan') {
            steps {
                echo "======================================================"
                echo "OWASP: Dependency Vulnerability Scanning"
                echo "======================================================"
                dir('app') {
                    script {
                        // OWASP Dependency Check
                        sh '''
                            echo "SECURITY: Running OWASP Dependency Check..."
                            dependency-check.sh \
                                --project "SPF-Invoice-Service" \
                                --scan . \
                                --format ALL \
                                --out dependency-check-report \
                                --data ${DEPENDENCY_CHECK_DATA} \
                                --failOnCVSS 7.0 \
                                --suppression suppression.xml
                        '''
                        
                        // NuGet audit intégré .NET
                        bat '''
                            echo "SECURITY: Running .NET NuGet audit..."
                            dotnet list package --vulnerable --include-transitive
                            dotnet restore --verbosity normal
                        '''
                    }
                }
            }
            post {
                always {
                    // Publication rapport vulnérabilités
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'app/dependency-check-report',
                        reportFiles: 'dependency-check-report.html',
                        reportName: 'OWASP Dependency Check Report'
                    ])
                    
                    // Archive pour audit
                    archiveArtifacts artifacts: 'app/dependency-check-report/**', 
                                   allowEmptyArchive: false
                }
            }
        }
        
        stage('Secure Build') {
            steps {
                echo "======================================================"
                echo "SECURITY: Secure Build Process"
                echo "======================================================"
                dir('app') {
                    bat '''
                        echo "SECURITY: Building with security flags..."
                        dotnet build \
                            --configuration Release \
                            --verbosity normal \
                            --property:TreatWarningsAsErrors=true \
                            --property:WarningsAsErrors="" \
                            --property:RunAnalyzersDuringBuild=true
                    '''
                }
            }
            post {
                success {
                    dir('app') {
                        // Signature artefacts de build
                        script {
                            sh '''
                                echo "SECURITY: Signing build artifacts..."
                                find ./bin -name "*.dll" -exec sha256sum {} + > build-checksums.txt
                                echo "SUCCESS: Artifacts signed"
                            '''
                        }
                    }
                }
            }
        }
        
        stage('SAST Security Analysis') {
            parallel {
                stage('SonarQube SAST') {
                    steps {
                        dir('app') {
                            withSonarQubeEnv('SonarQube') {
                                bat '''
                                    echo "SECURITY: Running SAST analysis..."
                                    sonar-scanner.bat \
                                    -Dsonar.projectKey=spf-invoice-service \
                                    -Dsonar.sources=. \
                                    -Dsonar.exclusions=**/bin/**,**/obj/**,**/wwwroot/lib/** \
                                    -Dsonar.qualitygate.wait=true \
                                    -Dsonar.security.review.wait=true \
                                    -Dsonar.qualitygate.timeout=300
                                '''
                            }
                        }
                    }
                }
                
                stage('Security Code Scan') {
                    steps {
                        dir('app') {
                            bat '''
                                echo "SECURITY: Running Security Code Scan..."
                                dotnet tool install --global security-scan
                                security-scan --project . --export security-report.json
                            '''
                        }
                    }
                }
            }
            post {
                always {
                    script {
                        // Quality Gate validation obligatoire
                        timeout(time: 5, unit: 'MINUTES') {
                            def qualityGate = waitForQualityGate()
                            if (qualityGate.status != 'OK') {
                                error "SECURITY GATE FAILED: Quality gate status: ${qualityGate.status}"
                            }
                        }
                    }
                }
            }
        }
        
        stage('Secure Testing') {
            when {
                expression { params.RUN_TESTS != 'false' }
            }
            steps {
                echo "======================================================"
                echo "SECURITY: Secure Test Execution"
                echo "======================================================"
                dir('tests') {
                    script {
                        // Validation packages test sécurisés
                        bat '''
                            echo "SECURITY: Validating test dependencies..."
                            npm audit --audit-level moderate
                            echo "SECURITY: Installing secure browser..."
                            npx playwright install chromium --with-deps
                        '''
                        
                        // Tests avec isolation sécurisée
                        bat '''
                            echo "SECURITY: Running secure E2E tests..."
                            set NODE_OPTIONS="--max-old-space-size=4096"
                            npm test -- --reporter=json --output-file=test-results.json
                        '''
                    }
                }
            }
            post {
                always {
                    dir('tests') {
                        // Nettoyage données sensibles des reports
                        script {
                            sh '''
                                echo "SECURITY: Sanitizing test reports..."
                                # Suppression potentiels secrets des logs
                                find test-results -name "*.log" -exec sed -i 's/password=[^&]*/password=****/g' {} +
                                find test-results -name "*.json" -exec sed -i 's/"token":"[^"]*"/"token":"****"/g' {} +
                            '''
                        }
                    }
                    
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'tests/playwright-report',
                        reportFiles: 'index.html',
                        reportName: 'Secure Test Report'
                    ])
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Audit trail sécurisé
                def auditLog = [
                    timestamp: BUILD_TIMESTAMP,
                    buildNumber: BUILD_NUMBER,
                    gitHash: BUILD_HASH,
                    result: currentBuild.result,
                    duration: currentBuild.duration,
                    user: env.BUILD_USER ?: 'system'
                ]
                writeJSON file: 'security-audit.json', json: auditLog
                archiveArtifacts artifacts: 'security-audit.json'
            }
        }
        
        success {
            echo "SUCCESS: Security pipeline completed - All gates passed"
            script {
                // Notification sécurisée (pas de données sensibles)
                emailext (
                    subject: "SECURE BUILD SUCCESS: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: "Build completed successfully with all security gates passed.",
                    to: "${env.BUILD_USER_EMAIL}"
                )
            }
        }
        
        failure {
            echo "SECURITY ALERT: Pipeline failed - Security review required"
            script {
                // Alert sécurité
                emailext (
                    subject: "SECURITY ALERT: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: "Security pipeline failed. Immediate review required.",
                    to: "security-team@company.com"
                )
            }
        }
        
        cleanup {
            // Nettoyage sécurisé
            sh '''
                echo "SECURITY: Secure cleanup..."
                find . -name "*.tmp" -delete
                find . -name "*.log" -exec shred -u {} + 2>/dev/null || true
            '''
        }
    }
}